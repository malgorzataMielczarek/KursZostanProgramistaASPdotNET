# [LEKCJA 2 – Entity Framework](https://kurs.szkoladotneta.pl/zostan-programista-asp-net/tydzien-7-bazy-danych/lekcja-2-entity-framework/)
Do połączenia naszej aplikacji z bazą danych będziemy używać odpowiedniej biblioteki nazywanej ORM. ORM, czyli _**O**bject-**r**elational **M**aping_ (mapowanie obiektowo-relacyjne), nazywamy biblioteki przeznaczone do połączenia aplikacji z odpowiednią bazą danych. Jak sama nazwa wskazuje będziemy jej używać do przetrzymywania obiektów, które będą reprezentowały tabele z naszej bazy danych oraz definiowania występujących między nimi relacji. W środowisku .NET najczęściej stosowaną biblioteką jest _Entity Framework_ (obecnie w wersji _Core_, stosowana w _ASP.NET Core_). Istnieją oczywiście inne ORMy używane w różnych środowiskach. Innym popularnym rozwiązaniem dla środowiska .NET jest _NHibernate_. Wywodzi się on ze stworzonej dla Javy biblioteki _Hibernate_ dla której powstał tzw. port dla .NET-a, jednak obecnie są to zupełnie oddzielne projekty (niezależnie rozwijane i utrzymywane). Programiści chętnie używają również projektu _Dapper_, który jest tzw. małym ORM-em. Docenia się go za szybkość działania. _Entity Framework Core_ jest jednak obecnie mocno rozwijany przez firmę Microsoft, więc chociażby przewaga w szybkości działania jaką jeszcze niedawno miał _Dapper_ coraz bardziej się zaciera. Dodatkowo jest on świetnie zintegrowany z platformą .NET, dla której od początku był tworzony. Możemy przy jego pomocy tworzyć połączenie z bazą danych w aplikacjach na wszystkie platformy, nie tylko webowe, ale również desktopowe, czy nawet mobilne, pisane w Xamarinie. Mamy również szeroki wachlarz możliwości, jeśli chodzi o typ bazy danych z jakim chcemy się połączyć. Może to być chociażby Microsoft SQL Server (MS SQL), MySQL, PostgreSQL, SQLite.
## Instalacja biblioteki
1. Otwieramy menadżer paczek NuGet<br />
_Tools_ -> _NuGet Package Manager_ -> _Manage NuGet Packages for Solution..._<br />
lub<br />
_Solution Explorer_ -> prawym przyciskiem myszki na naszym projekcie _.Infrastructure_ -> _Manage NuGet Packages..._
2. Wyszukujemy paczki do instalacji<br />
Ogólnie będziemy chcieli zainstalować 3 paczki:
    1. _Microsoft.EntityFrameworkCore_ - nasze ORM
    2. _Microsoft.EntityFrameworkCore.SqlServer_ - rozszerzenie biblioteki dla odpowiedniego systemu zarządzania bazą danych. W tym wypadku jest to Microsoft SQL Server, ale jeżeli będziemy używać czegoś innego, to wyszukujemy odpowiednią inną paczkę.
    3. _Microsoft.EntityFrameworkCore.Tools_ - ta paczka nie jest obowiązkowa. Rozszerza nam ona nasz ORM o dodatkowe funkcje. Jest wykorzystywana do migracji.
3. Instalacja<br />
Po wyszukaniu odpowiedniej paczki instalujemy ją. Jeżeli otworzyliśmy menadżer dla całej solucji (pierwsza opcja z pierwszego punktu), to musimy jeszcze wybrać projekt dla którego chcemy wykonać instalację. Zaznaczamy wówczas nasz projekt _.Infrastructure_.

## _Entity Framework Core_ vs. _Entity Framework_
Zanim powstał .NET Core mieliśmy do dyspozycji _Entity Framework_. Obecnie został on zastąpiony przez napisany od nowa ORM _Entity Framework Core_. Przynajmniej na razie nie zostały w nim zaimplementowane wszystkie funkcjonalności z ostatniej (6.) wersji _Entity Framework_. Najważniejsze elementy, takie jak kontekst bazy danych, DbSety, czyli obiekty, które mapowane są na tabele bazy danych (dzięki nim mamy prostą możliwość dodawania, usuwania i wyszukiwania elementów w bazie danych), oczywiście działają. Dodatkowo mamy możliwość migracji, co ułatwia podejście _Code First_. Nie mamy natomiast kilku elementów takich jak chociażby automatyczne migracje (podczas uruchamiania projektu), czy część funkcjonalności związanych z leniwym ładowaniem (_lazy loading_) dla relacyjnych tabel. Istnieją jednak sposoby na obejście tych braków. Jest jednak kilka rzeczy, których nie było w _Entity Framework_, a które dodano do _Entity Framework Core_. Jest to między innymi baza danych _In-Memory_, czyli prosty framework do testowania połączenia z bazą danych (Obecnie trwa dyskusja, czy programiści testować części aplikacji w jakikolwiek sposób związane z _Entity Framework Core_, gdyż są to już wówczas de facto testy integracyjne, a nie jednostkowe.). Innym ważnym elementem, który dodano, jest standardowe wsparcie dla _Inversion of Control_, czyli dla implementacji _Dependenci Injection_, dzięki czemu można ją używać bez żadnych dodatkowych konfiguracji.